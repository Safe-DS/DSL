package tests.validation.declarations.experimental

@Experimental
annotation ExperimentalAnnotation
annotation ValidAnnotation

@Experimental
class ExperimentalClass
class ValidClass {

    @Experimental
    attr experimentalAttribute: Int
    attr validAttribute: Int
}

@Experimental
enum ExperimentalEnum
enum ValidEnum {
    @Experimental ExperimentalEnumVariant
    ValidEnumVariant
}

@Experimental
fun experimentalFunction()
fun validFunction(
    @Experimental experimentalParameter: Int = 1,
    validParameter: Int = 1
) -> (
    @Experimental experimentalResult: Int,
    validResult: Int
)

fun functionWithTypeParameters<@Experimental ExperimentalTypeParameter, ValidTypeParameter>() {

    /*
    * Showing an error for yields is pointless, since constraints must stay.
    * Deprecation is only relevant for callers.
    */
    constraint {
        // no_semantic_warning "The referenced declaration is experimental."
        »ExperimentalTypeParameter« sub Int,
        // no_semantic_warning "The referenced declaration is experimental."
        »ValidTypeParameter« sub Int
    }
}

@Experimental step experimentalStep() {}
step validStep() {}

// semantic_warning "The used annotation is experimental."
@»ExperimentalAnnotation«
// no_semantic_warning "The used annotation is experimental."
@»ValidAnnotation«
// no_semantic_warning "The used annotation is experimental."
@»Unresolved«
step testStep1(

    // semantic_warning "The referenced declaration is experimental."
    @Experimental experimentalParameter: »ExperimentalClass« = 1,
    // no_semantic_warning "The referenced declaration is experimental."
    validParameter: »ValidClass« = 1,

    // semantic_warning "The referenced declaration is experimental."
    param3: »ExperimentalEnum« = 1,
    // no_semantic_warning "The referenced declaration is experimental."
    param4: »ValidEnum« = 1,
    // no_semantic_warning "The referenced declaration is experimental."
    param5: »Unresolved« = 1
)
-> (
    @Experimental experimentalResult: Int,
    validResult: Int
) {

    // no_semantic_warning "The referenced declaration is experimental."
    »experimentalParameter«;
    // no_semantic_warning "The referenced declaration is experimental."
    »validParameter«;

    // semantic_warning "The referenced declaration is experimental."
    validParameter.»experimentalAttribute«;
    // no_semantic_warning "The referenced declaration is experimental."
    validParameter.»validAttribute«;

    // semantic_warning "The referenced declaration is experimental."
    ValidEnum.»ExperimentalEnumVariant«;
    // no_semantic_warning "The referenced declaration is experimental."
    ValidEnum.»ValidEnumVariant«;

    // semantic_warning "The referenced declaration is experimental."
    »experimentalFunction«();
    // no_semantic_warning "The referenced declaration is experimental."
    »validFunction«();

    validFunction(
        // semantic_warning "The corresponding parameter is experimental."
        »experimentalParameter = 1«,
        // no_semantic_warning "The corresponding parameter is experimental."
        »validParameter = 1«,
        // no_semantic_warning "The corresponding parameter is experimental."
        »unresolved = 1«,
    );

    validFunction(
        // semantic_warning "The corresponding parameter is experimental."
        »1«,
        // no_semantic_warning "The corresponding parameter is experimental."
        »1«,
        // no_semantic_warning "The corresponding parameter is experimental."
        »1«,
    );

    // semantic_warning "The referenced declaration is experimental."
    validFunction().»experimentalResult«;

    // no_semantic_warning "The referenced declaration is experimental."
    validFunction().»validResult«;

    functionWithTypeParameters<
        // semantic_warning "The corresponding type parameter is experimental."
        »ExperimentalTypeParameter = Int«,
        // no_semantic_warning "The corresponding type parameter is experimental."
        »ValidTypeParameter = Int«,
        // no_semantic_warning "The corresponding type parameter is experimental."
        »Unresolved = Int«
    >();

    functionWithTypeParameters<
        // semantic_warning "The corresponding type parameter is experimental."
        »Int«,
        // no_semantic_warning "The corresponding type parameter is experimental."
        »Int«,
        // no_semantic_warning "The corresponding type parameter is experimental."
        »Int«
    >();

    // semantic_warning "The referenced declaration is experimental."
    »experimentalStep«();
    // no_semantic_warning "The referenced declaration is experimental."
    »validStep«();

    // no_semantic_warning "The referenced declaration is experimental."
    »unresolved«;

    /*
     * Showing an error for yields is pointless, since we must yield something.
     * Deprecation is only relevant for callers.
     */

    // no_semantic_warning "The referenced declaration is experimental."
    yield »experimentalResult« = 1;
    // no_semantic_warning "The referenced declaration is experimental."
    yield »validResult« = 1;
}

step testStep2() -> (result1: Int, result2: Int, result3: Int) {
    // semantic_warning "The assigned declaration is experimental."
    // no_semantic_warning "The assigned declaration is experimental."
    // no_semantic_warning "The assigned declaration is experimental."
    »val a«, »val b«, »val c« = validFunction();

    // semantic_warning "The assigned declaration is experimental."
    // no_semantic_warning "The assigned declaration is experimental."
    // no_semantic_warning "The assigned declaration is experimental."
    »yield result1«, »yield result2«, »yield result3« = validFunction();

    // no_semantic_warning "The assigned declaration is experimental."
    // no_semantic_warning "The assigned declaration is experimental."
    // no_semantic_warning "The assigned declaration is experimental."
    »_«, »_«, »_« = validFunction();

    // no_semantic_warning "The assigned declaration is experimental."
    »val d« = a;
    // no_semantic_warning "The assigned declaration is experimental."
    »val e« = b;
    // no_semantic_warning "The assigned declaration is experimental."
    »val f« = 1;
}
