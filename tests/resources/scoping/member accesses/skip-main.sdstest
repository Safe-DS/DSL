package tests.scoping.references

import tests.languageTests.scoping.reference2.AnnotationInOtherPackage1
import tests.languageTests.scoping.reference2.ClassInOtherPackage1
import tests.languageTests.scoping.reference2.EnumInOtherPackage1
import tests.languageTests.scoping.reference2.globalFunctionInOtherPackage1
import tests.languageTests.scoping.reference2.internalStepInOtherPackage
import tests.languageTests.scoping.reference2.privateStepInOtherPackage
import tests.languageTests.scoping.reference2.stepInOtherPackage1
import tests.languageTests.scoping.reference2.pipelineInOtherPackage1

/*
inner class Reference {

        @Nested
        inner class MemberAccess {

            @Test
            fun `should resolve static class attribute accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToClassMembers")
                val classStaticAttributeInSameFile =
                    findUniqueDeclarationOrFail<SdsAttribute>("classStaticAttributeInSameFile")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(classStaticAttributeInSameFile)
            }

            @Test
            fun `should resolve instance class attribute accessed from class instance`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToClassMembers")
                val classInstanceAttributeInSameFile =
                    findUniqueDeclarationOrFail<SdsAttribute>("classInstanceAttributeInSameFile")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[3].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(classInstanceAttributeInSameFile)
            }

            @Test
            fun `should resolve nested class accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToClassMembers")
                val classInClassInSameFile =
                    findUniqueDeclarationOrFail<SdsClass>("ClassInClassInSameFile")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[5].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(classInClassInSameFile)
            }

            @Test
            fun `should resolve nested enum accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToClassMembers")
                val enumInClassInSameFile =
                    findUniqueDeclarationOrFail<SdsEnum>("EnumInClassInSameFile")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[7].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumInClassInSameFile)
            }

            @Test
            fun `should resolve static class method accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToClassMembers")
                val classStaticMethodInSameFile =
                    findUniqueDeclarationOrFail<SdsFunction>("classStaticMethodInSameFile")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[9].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(classStaticMethodInSameFile)
            }

            @Test
            fun `should resolve instance class method accessed from class instance`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToClassMembers")
                val classInstanceMethodInSameFile =
                    findUniqueDeclarationOrFail<SdsFunction>("classInstanceMethodInSameFile")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[11].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(classInstanceMethodInSameFile)
            }

            @Test
            fun `should resolve enum variants`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToEnumVariants")
                val enumVariantInSameFile =
                    findUniqueDeclarationOrFail<SdsEnumVariant>("EnumVariantInSameFile")

                val references = step.body.descendants<SdsReference>().toList()
                references.shouldHaveSize(2)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumVariantInSameFile)
            }

            @Test
            fun `should resolve enum variants from step annotation`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToEnumVariants")
                val enumVariantInSameFile =
                    findUniqueDeclarationOrFail<SdsEnumVariant>("EnumVariantInSameFile")

                val annotations = step.annotationCallsOrEmpty()
                annotations.shouldHaveSize(1)

                val references = annotations[0].descendants<SdsReference>().toList()
                references.shouldHaveSize(2)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumVariantInSameFile)
            }

            @Test
            fun `should resolve enum variants from parameter annotation`() = withResource(REFERENCE) {
                val parameter =
                    findUniqueDeclarationOrFail<SdsParameter>("referenceToEnumVariantFromParameterAnnotation")
                val enumVariantInSameFile =
                    findUniqueDeclarationOrFail<SdsEnumVariant>("EnumVariantInSameFile")

                val annotations = parameter.annotationCallsOrEmpty()
                annotations.shouldHaveSize(1)

                val references = annotations[0].descendants<SdsReference>().toList()
                references.shouldHaveSize(2)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumVariantInSameFile)
            }

            @Test
            fun `should resolve enum variants of nested enum from class annotation`() = withResource(REFERENCE) {
                val parameter = findUniqueDeclarationOrFail<SdsClass>("ReferencesToEnumVariantsInnerClass")
                val enumVariantInSameFile =
                    findUniqueDeclarationOrFail<SdsEnumVariant>("EnumVariantInSameClass")

                val annotations = parameter.annotationCallsOrEmpty()
                annotations.shouldHaveSize(2)

                val references = annotations[0].descendants<SdsReference>().toList()
                references.shouldHaveSize(2)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumVariantInSameFile)
            }

            @Test
            fun `should resolve enum variants of global enum from class annotation`() = withResource(REFERENCE) {
                val parameter = findUniqueDeclarationOrFail<SdsClass>("ReferencesToEnumVariantsInnerClass")
                val enumVariantInSameClass =
                    findUniqueDeclarationOrFail<SdsEnumVariant>("EnumVariantInSameFile")

                val annotations = parameter.annotationCallsOrEmpty()
                annotations.shouldHaveSize(2)

                val references = annotations[1].descendants<SdsReference>().toList()
                references.shouldHaveSize(2)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumVariantInSameClass)
            }

            @Test
            fun `should resolve parameters of enum variants`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToEnumVariantParameters")
                val enumVariantParameterInSameFile =
                    findUniqueDeclarationOrFail<SdsParameter>("enumVariantParameterInSameFile")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(3)

                val declaration = references[2].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumVariantParameterInSameFile)
            }

            @Test
            fun `should resolve inherited static class attribute accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToInheritedClassMembers")
                val superClassStaticAttribute =
                    findUniqueDeclarationOrFail<SdsAttribute>("superClassStaticAttribute")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(superClassStaticAttribute)
            }

            @Test
            fun `should resolve inherited instance class attribute accessed from class instance`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToInheritedClassMembers")
                    val superClassInstanceAttribute =
                        findUniqueDeclarationOrFail<SdsAttribute>("superClassInstanceAttribute")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(12)

                    val declaration = references[3].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(superClassInstanceAttribute)
                }

            @Test
            fun `should resolve inherited nested class accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToInheritedClassMembers")
                val classInSuperClass =
                    findUniqueDeclarationOrFail<SdsClass>("ClassInSuperClass")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[5].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(classInSuperClass)
            }

            @Test
            fun `should resolve inherited nested enum accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToInheritedClassMembers")
                val enumInSuperClass =
                    findUniqueDeclarationOrFail<SdsEnum>("EnumInSuperClass")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[7].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(enumInSuperClass)
            }

            @Test
            fun `should resolve inherited static class method accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToInheritedClassMembers")
                val superClassStaticMethod =
                    findUniqueDeclarationOrFail<SdsFunction>("superClassStaticMethod")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(12)

                val declaration = references[9].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(superClassStaticMethod)
            }

            @Test
            fun `should resolve inherited instance class method accessed from class instance`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToInheritedClassMembers")
                    val superClassInstanceMethod =
                        findUniqueDeclarationOrFail<SdsFunction>("superClassInstanceMethod")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(12)

                    val declaration = references[11].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(superClassInstanceMethod)
                }

            @Test
            fun `should resolve overridden instance attribute`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToOverriddenMembers")
                val subClassForOverriding = findUniqueDeclarationOrFail<SdsClass>("SubClassForOverriding")
                val instanceAttributeForOverriding =
                    subClassForOverriding.findUniqueDeclarationOrFail<SdsAttribute>("instanceAttributeForOverriding")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(8)

                val declaration = references[5].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(instanceAttributeForOverriding)
            }

            @Test
            fun `should resolve overridden instance method`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToOverriddenMembers")
                val subClassForOverriding = findUniqueDeclarationOrFail<SdsClass>("SubClassForOverriding")
                val instanceMethodForOverriding =
                    subClassForOverriding.findUniqueDeclarationOrFail<SdsFunction>("instanceMethodForOverriding")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(8)

                val declaration = references[7].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(instanceMethodForOverriding)
            }

            @Test
            fun `should resolve hidden static attribute`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToHiddenMembers")
                val subClassForHiding = findUniqueDeclarationOrFail<SdsClass>("SubClassForHiding")
                val staticAttributeForHiding =
                    subClassForHiding.findUniqueDeclarationOrFail<SdsAttribute>("staticAttributeForHiding")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(8)

                val declaration = references[1].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(staticAttributeForHiding)
            }

            @Test
            fun `should resolve hidden nested class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToHiddenMembers")
                val subClassForHiding = findUniqueDeclarationOrFail<SdsClass>("SubClassForHiding")
                val nestedClassForHiding =
                    subClassForHiding.findUniqueDeclarationOrFail<SdsClass>("NestedClassForHiding")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(8)

                val declaration = references[3].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(nestedClassForHiding)
            }

            @Test
            fun `should resolve hidden nested enum`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToHiddenMembers")
                val subClassForHiding = findUniqueDeclarationOrFail<SdsClass>("SubClassForHiding")
                val nestedEnumForHiding =
                    subClassForHiding.findUniqueDeclarationOrFail<SdsEnum>("NestedEnumForHiding")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(8)

                val declaration = references[5].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(nestedEnumForHiding)
            }

            @Test
            fun `should resolve hidden static method`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToHiddenMembers")
                val subClassForHiding = findUniqueDeclarationOrFail<SdsClass>("SubClassForHiding")
                val staticMethodForHiding =
                    subClassForHiding.findUniqueDeclarationOrFail<SdsFunction>("staticMethodForHiding")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(8)

                val declaration = references[7].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(staticMethodForHiding)
            }

            @Test
            fun `should not resolve static class members accessed from instance`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToStaticClassMembersFromInstance")
                val classInSameFile = findUniqueDeclarationOrFail<SdsClass>("ClassInSameFile")

                val references = step.descendants<SdsReference>()
                    .filter { it.declaration != classInSameFile }
                    .toList()
                references.shouldHaveSize(8)
                references.forEachAsClue {
                    it.declaration.shouldNotBeResolved()
                }
            }

            @Test
            fun `should not resolve instance class members accessed from class`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToInstanceClassMembersFromClass")
                val classInSameFile = findUniqueDeclarationOrFail<SdsClass>("ClassInSameFile")

                val references = step.descendants<SdsReference>()
                    .filter { it.declaration != classInSameFile }
                    .toList()
                references.shouldHaveSize(4)
                references.forEachAsClue {
                    it.declaration.shouldNotBeResolved()
                }
            }

            @Test
            fun `should not resolve class members with unqualified access`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("unqualifiedReferencesToClassMembers")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(6)
                references.forEachAsClue {
                    it.declaration.shouldNotBeResolved()
                }
            }

            @Test
            fun `should not resolve enum variants with unqualified access`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("unqualifiedReferencesToEnumVariants")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(1)
                references[0].declaration.shouldNotBeResolved()
            }

            @Test
            fun `should not resolve parameters of enum variants with unqualified access`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("unqualifiedReferencesToEnumVariantParameters")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(1)
                references[0].declaration.shouldNotBeResolved()
            }

            @Test
            fun `should resolve result of callable type with one result without matching member`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToCallableTypeResults")
                    val singleResult = step.findUniqueDeclarationOrFail<SdsResult>("singleResult")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(8)

                    val declaration = references[1].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(singleResult)
                }

            @Test
            fun `should resolve attribute for callable type with one result with matching class attribute`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToCallableTypeResults")
                    val classForResultMemberAccess = findUniqueDeclarationOrFail<SdsClass>("ClassForResultMemberAccess")
                    val result = classForResultMemberAccess.findUniqueDeclarationOrFail<SdsAttribute>("result")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(8)

                    val declaration = references[3].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(result)
                }

            @Test
            fun `should resolve result for callable type with one result with matching enum variant`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToCallableTypeResults")
                    val callableWithOneResultWithIdenticalEnumVariant =
                        step.findUniqueDeclarationOrFail<SdsParameter>("callableWithOneResultWithIdenticalEnumVariant")
                    val result =
                        callableWithOneResultWithIdenticalEnumVariant.findUniqueDeclarationOrFail<SdsResult>("result")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(8)

                    val declaration = references[5].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(result)
                }

            @Test
            fun `should resolve result of callable type with multiple results`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToCallableTypeResults")
                val result1 = step.findUniqueDeclarationOrFail<SdsResult>("result1")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(8)

                val declaration = references[7].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(result1)
            }

            @Test
            fun `should resolve result of function with one result without matching member`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToFunctionResults")
                    val globalFunctionResultInSameFile =
                        findUniqueDeclarationOrFail<SdsResult>("globalFunctionResultInSameFile")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(6)

                    val declaration = references[1].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(globalFunctionResultInSameFile)
                }

            @Test
            fun `should resolve member for function with one result with matching member`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToFunctionResults")
                    val classForResultMemberAccess = findUniqueDeclarationOrFail<SdsClass>("ClassForResultMemberAccess")
                    val result = classForResultMemberAccess.findUniqueDeclarationOrFail<SdsAttribute>("result")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(6)

                    val declaration = references[3].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(result)
                }

            @Test
            fun `should resolve result of function with multiple results`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToFunctionResults")
                val globalFunctionWithTwoResults =
                    findUniqueDeclarationOrFail<SdsFunction>("globalFunctionWithTwoResults")
                val result1 = globalFunctionWithTwoResults.findUniqueDeclarationOrFail<SdsResult>("result1")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(6)

                val declaration = references[5].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(result1)
            }

            @Test
            fun `should resolve result of lambda with one result without matching member`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToLambdaResults")
                val singleResult = step.findUniqueDeclarationOrFail<SdsBlockLambdaResult>("singleResult")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(7)

                val declaration = references[2].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(singleResult)
            }

            @Test
            fun `should resolve member for lambda with one result with matching member`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToLambdaResults")
                    val classForResultMemberAccess = findUniqueDeclarationOrFail<SdsClass>("ClassForResultMemberAccess")
                    val result = classForResultMemberAccess.findUniqueDeclarationOrFail<SdsAttribute>("result")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(7)

                    val declaration = references[4].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(result)
                }

            @Test
            fun `should resolve result of lambda with multiple results`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToLambdaResults")
                val result1 = step.findUniqueDeclarationOrFail<SdsBlockLambdaResult>("result1")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(7)

                val declaration = references[6].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(result1)
            }

            @Test
            fun `should resolve result of step with one result without matching member`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToStepResults")
                    val stepResultInSameFile = findUniqueDeclarationOrFail<SdsResult>("stepResultInSameFile")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(6)

                    val declaration = references[1].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(stepResultInSameFile)
                }

            @Test
            fun `should resolve member for step with one result with matching member`() =
                withResource(REFERENCE) {
                    val step = findUniqueDeclarationOrFail<SdsStep>("referencesToStepResults")
                    val classForResultMemberAccess = findUniqueDeclarationOrFail<SdsClass>("ClassForResultMemberAccess")
                    val result = classForResultMemberAccess.findUniqueDeclarationOrFail<SdsAttribute>("result")

                    val references = step.descendants<SdsReference>().toList()
                    references.shouldHaveSize(6)

                    val declaration = references[3].declaration
                    declaration.shouldBeResolved()
                    declaration.shouldBe(result)
                }

            @Test
            fun `should resolve result of step with multiple results`() = withResource(REFERENCE) {
                val step = findUniqueDeclarationOrFail<SdsStep>("referencesToStepResults")
                val stepInSameFileWithTwoResults =
                    findUniqueDeclarationOrFail<SdsStep>("stepWithTwoResults")
                val result1 = stepInSameFileWithTwoResults.findUniqueDeclarationOrFail<SdsResult>("result1")

                val references = step.descendants<SdsReference>().toList()
                references.shouldHaveSize(6)

                val declaration = references[5].declaration
                declaration.shouldBeResolved()
                declaration.shouldBe(result1)
            }
        }
    }
*/

annotation AnnotationInSameFile

class SuperClass {
    static attr superClassStaticAttribute: Int
    attr superClassInstanceAttribute: Int

    class ClassInSuperClass

    enum EnumInSuperClass

    static fun superClassStaticMethod()
    fun superClassInstanceMethod()
}
class ClassInSameFile<TYPE_PARAMETER_IN_SAME_FILE>() sub SuperClass {
    static attr classStaticAttributeInSameFile: Int
    attr classInstanceAttributeInSameFile: Int

    class ClassInClassInSameFile

    enum EnumInClassInSameFile

    static fun classStaticMethodInSameFile() -> classStaticMethodResultInSameFile: Int
    fun classInstanceMethodInSameFile() -> classInstanceMethodResultInSameFile: Int
}

enum EnumInSameFile {
    EnumVariantInSameFile(enumVariantParameterInSameFile: Int)
}

fun globalFunctionInSameFile(globalFunctionParameterInSameFile: Int) -> globalFunctionResultInSameFile: Int
fun globalFunctionWithOneResultWithIdenticalMember() -> result: ClassForResultMemberAccess
fun globalFunctionWithTwoResults() -> (result1: Int, result2: Int)


step stepInSameFile(stepParameterInSameFile: Int) -> stepResultInSameFile: Int {
    val placeholderInSameFile = 1;
}
step stepWithOneResultWithIdenticalMember() -> result: ClassForResultMemberAccess {}
step stepWithTwoResults() -> (result1: Int, result2: Int) {}

step internalStepInSameFile() {}
step privateStepInSameFile() {}

pipeline pipelineInSameFile {}

class SuperClassForOverriding() {
    attr instanceAttributeForOverriding: Int
    fun instanceMethodForOverriding()
}
class SubClassForOverriding()
sub SuperClassForOverriding {
    attr instanceAttributeForOverriding: Int
    fun instanceMethodForOverriding()
}

class SuperClassForHiding {
    static attr staticAttributeForHiding: Int
    class NestedClassForHiding
    enum NestedEnumForHiding
    static fun staticMethodForHiding()
}
class SubClassForHiding sub SuperClassForHiding {
    static attr staticAttributeForHiding: Int
    class NestedClassForHiding
    enum NestedEnumForHiding
    static fun staticMethodForHiding()
}

class ClassForResultMemberAccess() {
    attr result: Int
}
enum EnumForResultMemberAccess {
    result
}


// Access to own members -------------------------------------------------------

step referencesToClassMembers() {
    ClassInSameFile.classStaticAttributeInSameFile;
    ClassInSameFile<*>().classInstanceAttributeInSameFile;
    ClassInSameFile.ClassInClassInSameFile;
    ClassInSameFile.EnumInClassInSameFile;
    ClassInSameFile.classStaticMethodInSameFile;
    ClassInSameFile<*>().classInstanceMethodInSameFile();
}

@Target(EnumInSameFile.EnumVariantInSameFile)
step referencesToEnumVariants(@Target(EnumInSameFile.EnumVariantInSameFile) referenceToEnumVariantFromParameterAnnotation: Int) {
    EnumInSameFile.EnumVariantInSameFile;
}

class ReferencesToEnumVariants {
    @Target(EnumInSameClass.EnumVariantInSameClass)
    @Target(EnumInSameFile.EnumVariantInSameFile)
    class ReferencesToEnumVariantsInnerClass

    enum EnumInSameClass {
        EnumVariantInSameClass
    }
}

step referencesToEnumVariantParameters() {
    EnumInSameFile.EnumVariantInSameFile.enumVariantParameterInSameFile;
}


// Access to inherited members -------------------------------------------------

step referencesToInheritedClassMembers() {
    ClassInSameFile.superClassStaticAttribute;
    ClassInSameFile<*>().superClassInstanceAttribute;
    ClassInSameFile.ClassInSuperClass;
    ClassInSameFile.EnumInSuperClass;
    ClassInSameFile.superClassStaticMethod;
    ClassInSameFile<*>().superClassInstanceMethod();
}


// Overriding ------------------------------------------------------------------
step referencesToOverriddenMembers() {
    SuperClassForOverriding().instanceAttributeForOverriding;
    SuperClassForOverriding().instanceMethodForOverriding();

    SubClassForOverriding().instanceAttributeForOverriding;
    SubClassForOverriding().instanceMethodForOverriding();
}

// Hiding ----------------------------------------------------------------------
step referencesToHiddenMembers() {
    SubClassForHiding.staticAttributeForHiding;
    SubClassForHiding.NestedClassForHiding;
    SubClassForHiding.NestedEnumForHiding;
    SubClassForHiding.staticMethodForHiding;
}

// Access to static members from instance --------------------------------------

step referencesToStaticClassMembersFromInstance() {
    ClassInSameFile<*>().classStaticAttributeInSameFile;
    ClassInSameFile<*>().ClassInClassInSameFile;
    ClassInSameFile<*>().EnumInClassInSameFile;
    ClassInSameFile<*>().classStaticMethodInSameFile;

    ClassInSameFile<*>().superClassStaticAttribute;
    ClassInSameFile<*>().ClassInSuperClass;
    ClassInSameFile<*>().EnumInSuperClass;
    ClassInSameFile<*>().superClassStaticMethod;
}


// Access to instance members from class ---------------------------------------

step referencesToInstanceClassMembersFromClass() {
    ClassInSameFile.classInstanceAttributeInSameFile;
    ClassInSameFile.classInstanceMethodInSameFile();

    ClassInSameFile.superClassInstanceAttribute;
    ClassInSameFile.superClassInstanceMethod();
}


// Access to results of callable -----------------------------------------------

step referencesToCallableTypeResults(
    callableWithOneResult: () -> (singleResult: Int),
    callableWithOneResultWithIdenticalClassAttribute: () -> (result: ClassForResultMemberAccess),
    callableWithOneResultWithIdenticalEnumVariant: () -> (result: EnumForResultMemberAccess),
    callableWithTwoResults: () -> (result1: Int, result2: Int)
) {
    callableWithOneResult().singleResult;
    callableWithOneResultWithIdenticalClassAttribute().result;
    callableWithOneResultWithIdenticalEnumVariant().result;
    callableWithTwoResults().result1;
}

step referencesToFunctionResults() {
    globalFunctionInSameFile(1).globalFunctionResultInSameFile;
    globalFunctionWithOneResultWithIdenticalMember().result;
    globalFunctionWithTwoResults().result1;
}

step referencesToLambdaResults() {
    val lambdaWithOneResult = () {
        yield singleResult = 1;
    };
    val lambdaWithOneResultWithIdenticalMember = () {
        yield result = ClassForResultMemberAccess();
    };
    val lambdaWithTwoResults = () {
        yield result1 = 1;
        yield result2 = 1;
    };

    lambdaWithOneResult().singleResult;
    lambdaWithOneResultWithIdenticalMember().result;
    lambdaWithTwoResults().result1;
}

step referencesToStepResults() {
    stepInSameFile(1).stepResultInSameFile;
    stepWithOneResultWithIdenticalMember().result;
    stepWithTwoResults().result1;
}
