package safeds.data.tabular.containers

from safeds.data.tabular.containers import Column, Row, Table

/**
 * A tagged table is a table that additionally knows which columns are features and which are the target to predict.
 *
 * @param data The data.
 * @param targetName Name of the target column.
 * @param featureNames Names of the feature columns. If None, all columns except the target column are used.
 *
 * @example
 * pipeline example {
 *     // TODO
 * }
 */
@Experimental
class TaggedTable(
    data: Map<String, List<Any>>,
    @PythonName("target_name") targetName: String,
    @PythonName("feature_names") featureNames: List<String>? = null
) sub Table {
    /**
     * Get the feature columns of the tagged table.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    attr features: Table
    /**
     * Get the target column of the tagged table.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    attr target: Column

    /**
     * Return a new table with the provided column attached at the end, as a feature column.
     *
     * the original table is not modified.
     *
     * @param column The column to be added.
     *
     * @result result1 The table with the attached feature column.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("add_column_as_feature")
    fun addColumnAsFeature(
        column: Column
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with the provided columns attached at the end, as feature columns.
     *
     * The original table is not modified.
     *
     * @param columns The columns to be added as features.
     *
     * @result result1 The table with the attached feature columns.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("add_columns_as_features")
    fun addColumnsAsFeatures(
        columns: union<List<Column>, Table>
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with the provided column attached at the end, as neither target nor feature column.
     *
     * The original table is not modified.
     *
     * @param column The column to be added.
     *
     * @result result1 The table with the column attached as neither target nor feature column.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("add_column")
    fun addColumn(
        column: Column
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with multiple added columns, as neither target nor feature columns.
     *
     * The original table is not modified.
     *
     * @param columns The columns to be added.
     *
     * @result result1 A new table combining the original table and the given columns as neither target nor feature columns.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("add_columns")
    fun addColumns(
        columns: union<List<Column>, Table>
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with an added Row attached.
     *
     * The original table is not modified.
     *
     * @param row The row to be added.
     *
     * @result result1 A new tagged table with the added row at the end.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("add_row")
    fun addRow(
        row: Row
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with multiple added Rows attached.
     *
     * The original table is not modified.
     *
     * @param rows The rows to be added.
     *
     * @result result1 A new tagged table which combines the original table and the given rows.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("add_rows")
    fun addRows(
        rows: union<List<Row>, Table>
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` containing only rows that match the given Callable (e.g. lambda function).
     *
     * The original tagged table is not modified.
     *
     * @param query A Callable that is applied to all rows.
     *
     * @result result1 A new tagged table containing only the rows to match the query.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("filter_rows")
    fun filterRows(
        query: (row: Row) -> matches: Boolean
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with only the given column(s).
     *
     * The original table is not modified.
     *
     * @param columnNames A list containing only the columns to be kept.
     *
     * @result result1 A table containing only the given column(s).
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("keep_only_columns")
    fun keepOnlyColumns(
        @PythonName("column_names") columnNames: List<String>
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with the given column(s) removed from the table.
     *
     * The original table is not modified.
     *
     * @param columnNames The names of all columns to be dropped.
     *
     * @result result1 A table without the given columns.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("remove_columns")
    fun removeColumns(
        @PythonName("column_names") columnNames: List<String>
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with every column that misses values removed.
     *
     * The original table is not modified.
     *
     * @result result1 A table without the columns that contain missing values.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("remove_columns_with_missing_values")
    fun removeColumnsWithMissingValues() -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with every column that contains non-numerical values removed.
     *
     * The original table is not modified.
     *
     * @result result1 A table without the columns that contain non-numerical values.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("remove_columns_with_non_numerical_values")
    fun removeColumnsWithNonNumericalValues() -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with all row duplicates removed.
     *
     * The original table is not modified.
     *
     * @result result1 The table with the duplicate rows removed.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("remove_duplicate_rows")
    fun removeDuplicateRows() -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` without the rows that contain missing values.
     *
     * The original table is not modified.
     *
     * @result result1 A table without the rows that contain missing values.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("remove_rows_with_missing_values")
    fun removeRowsWithMissingValues() -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with all rows that contain at least one outlier removed.
     *
     * We define an outlier as a value that has a distance of more than 3 standard deviations from the column mean.
     * Missing values are not considered outliers. They are also ignored during the calculation of the standard
     * deviation.
     *
     * The original table is not modified.
     *
     * @result result1 A new table without rows containing outliers.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("remove_rows_with_outliers")
    fun removeRowsWithOutliers() -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with a single column renamed.
     *
     * The original table is not modified.
     *
     * @param oldName The old name of the target column.
     * @param newName The new name of the target column.
     *
     * @result result1 The Table with the renamed column.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("rename_column")
    fun renameColumn(
        @PythonName("old_name") oldName: String,
        @PythonName("new_name") newName: String
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with the specified old column replaced by a list of new columns.
     *
     * If the column to be replaced is the target column, it must be replaced by exactly one column. That column
     * becomes the new target column. If the column to be replaced is a feature column, the new columns that replace it
     * all become feature columns.
     *
     * The order of columns is kept. The original table is not modified.
     *
     * @param oldColumnName The name of the column to be replaced.
     * @param newColumns The new columns replacing the old column.
     *
     * @result result1 A table with the old column replaced by the new column.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("replace_column")
    fun replaceColumn(
        @PythonName("old_column_name") oldColumnName: String,
        @PythonName("new_columns") newColumns: List<Column>
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with randomly shuffled rows of this table.
     *
     * The original table is not modified.
     *
     * @result result1 The shuffled Table.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("shuffle_rows")
    fun shuffleRows() -> result1: TaggedTable

    /**
     * Slice a part of the table into a new `TaggedTable`.
     *
     * The original table is not modified.
     *
     * @param start The first index of the range to be copied into a new table, None by default.
     * @param end The last index of the range to be copied into a new table, None by default.
     * @param step The step size used to iterate through the table, 1 by default.
     *
     * @result result1 The resulting table.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("slice_rows")
    fun sliceRows(
        start: Int? = null,
        end: Int? = null,
        step: Int = 1
    ) -> result1: TaggedTable

    /**
     * Sort the columns of a `TaggedTable` with the given comparator and return a new `TaggedTable`.
     *
     * The comparator is a function that takes two columns `col1` and `col2` and
     * returns an integer:
     *
     * * If the function returns a negative number, `col1` will be ordered before `col2`.
     * * If the function returns a positive number, `col1` will be ordered after `col2`.
     * * If the function returns 0, the original order of `col1` and `col2` will be kept.
     *
     * If no comparator is given, the columns will be sorted alphabetically by their name.
     *
     * The original table is not modified.
     *
     * @param comparator The function used to compare two columns.
     *
     * @result result1 A new table with sorted columns.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("sort_columns")
    fun sortColumns(
        comparator: (param1: Column, param2: Column) -> param3: Int
    ) -> result1: TaggedTable

    /**
     * Sort the rows of a `TaggedTable` with the given comparator and return a new `TaggedTable`.
     *
     * The comparator is a function that takes two rows `row1` and `row2` and
     * returns an integer:
     *
     * * If the function returns a negative number, `row1` will be ordered before `row2`.
     * * If the function returns a positive number, `row1` will be ordered after `row2`.
     * * If the function returns 0, the original order of `row1` and `row2` will be kept.
     *
     * The original table is not modified.
     *
     * @param comparator The function used to compare two rows.
     *
     * @result result1 A new table with sorted rows.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("sort_rows")
    fun sortRows(
        comparator: (param1: Row, param2: Row) -> param3: Int
    ) -> result1: TaggedTable

    /**
     * Return a new `TaggedTable` with the provided column transformed by calling the provided transformer.
     *
     * The original table is not modified.
     *
     * @result transformedTable The table with the transformed column.
     *
     * @example
     * pipeline example {
     *     // TODO
     * }
     */
    @Pure
    @PythonName("transform_column")
    fun transformColumn(
        name: String,
        transformer: (row: Row) -> newColumnValue: Any?
    ) -> transformedTable: TaggedTable
}
